/* Plugin Template generated by Pawn Studio */

#pragma semicolon 1

#include <sourcemod>
#include <sdktools>
#include <tf2>
#include <tf2_stocks>

#define PL_VERSION "1.0"

#define SOUND_FREEZE	"physics/glass/glass_impact_bullet4.wav"

#define TF_CLASS_DEMOMAN		4
#define TF_CLASS_ENGINEER		9
#define TF_CLASS_HEAVY			6
#define TF_CLASS_MEDIC			5
#define TF_CLASS_PYRO		    7
#define TF_CLASS_SCOUT			1
#define TF_CLASS_SNIPER			2
#define TF_CLASS_SOLDIER		3
#define TF_CLASS_SPY			8
#define TF_CLASS_UNKNOWN		0

#define TF_TEAM_BLU					3
#define TF_TEAM_RED					2

//Color codes. (Light blue would be lovely for the [FT] prefix, but alas, we lack proper coloring)
#define cDefault				0x01
#define cLightGreen 			0x03
#define cGreen					0x04
#define cDarkGreen  			0x05

new g_iClass[MAXPLAYERS + 1];
//Keeps track of frozen status of all players
new bool:g_bFrozen[MAXPLAYERS+1] = { false, ... };

new databaseClient = 0;

new g_iMedicKills[MAXPLAYERS+1] = {0, ...};
new g_iPlayersFrozen[MAXPLAYERS+1] = {0, ...};

new g_sClientIDS[MAXPLAYERS+1][64];
new g_sClientNames[MAXPLAYERS+1][64];

new Handle:db = INVALID_HANDLE;

//Timers to handle auto unfreeze for each player
new Handle:g_hUnfreezeTimer[MAXPLAYERS+1] = { INVALID_HANDLE, ... }; 

//Losers stay frozen, winners get to do what they want
new bool:g_bIsHumiliationRound = false;

//The team that won the humiliation round. (RED_TEAM || BLU_TEAM)
new g_iHumiliationRoundWinners = 0;

//Stores the actual enabled state of freeze tag. Turned off after rounds and back on in the next round. 
//Using this instead of the cvar so I can install ftmode voting soon.
new bool:g_bFreezeTagEnabled = false;

//Will medics be allowed to heal themselves? TODO: convar this
//new bool:g_bRemoveMedicAutoheal = true;

//Seconds to automatically unfreeze a frozen player. Value of 0 will disable auto-unfreeze
new Handle:g_cvAutoUnfreeze = INVALID_HANDLE;

//Should freeze tag be enabled on the server or not
new Handle:g_cvFreezeTagEnabled = INVALID_HANDLE;

new Handle:g_hEnabled;

public Plugin:myinfo = 
{
	name = "Fight Club Freeze Tag Combat",
	author = "Andre Daenitz and Jason Kanagaratnam",
	description = "Sets combat rules for Freeze Tag",
	version = "1.0",
	url = "<- URL ->"
}

/*	If we're running freeze tag, tell them */
public OnClientPutInServer(client)
{
	DisplayRules(client);	
		
	decl String:id[64];
	decl String:name[64];
	GetClientAuthString(client, id, 63);
	GetClientName(client, name, 63);
	
	g_sClientIDS[client] = id;
	g_sClientNames[client] = name;
	
	g_iMedicKills[client] = 0;
	g_iPlayersFrozen[client] = 0;
}

DisplayRules(client)
{	
	decl String:message[128];
	Format(message, sizeof(message), "%c[FT]%c * Attack enemies to freeze them, medics can heal to unfreeze.", cGreen, cDefault);
	
	if (client == -1)
		PrintToChatAll(message);
	else
		PrintToChat(client, message);

	Format(message, sizeof(message), "%c[FT]%c * Each team gets one medic for every four scouts. Medics can't be frozen, but they CAN be killed!", cGreen, cDefault);
	if (client == -1)
		PrintToChatAll(message);
	else
		PrintToChat(client, message);
		
	Format(message, sizeof(message), "%c[FT]%c * First team to freeze all the opponent's scouts receives a mini humiliation round for 10 seconds!", cGreen, cDefault);
	if (client == -1)
		PrintToChatAll(message);
	else
		PrintToChat(client, message);

}

public OnPluginStart()
{
	CreateConVar("sm_freezetag_combat", PL_VERSION, "Enforce Freezetag Combat rules.", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
	g_hEnabled                                = CreateConVar("sm_freezetag_combat_enabled",       "1",  "Enable/disable Freeze Tag combat rules in TF2.");
	
	HookEvent("player_changeclass", Event_PlayerClass);
	HookEvent("player_spawn",       Event_PlayerSpawn);
	HookEvent("post_inventory_application", Event_BlockWeaponRespawn);
	HookEvent("player_hurt", Event_PlayerHurt);
	HookEvent("player_healed", Event_MedicUnfreeze);
	HookEvent("player_disconnect", Event_ClientDisconnect);

}

public Event_MedicUnfreeze(Handle:event, const String:name[], bool:dontBroadcast)
{
	PrintToServer("Medic Unfreeze");
	new patientId = GetEventInt(event, "patient");
	new patient = GetClientOfUserId(patientId);
	MedicUnfreezePlayer(patient, g_hUnfreezeTimer[patient]);
}

public MedicUnfreezePlayer(client, timer)
{
	if (g_hUnfreezeTimer[client] == timer) //if this timer wasn't killed/updated, let it do it's thing.
	{
		//Small hack to make sure Unfreeze doesn't closehandle this timer while it's active
		
		
		UnfreezePlayer(client);
	}
}

public Event_PlayerHurt(Handle:event, const String:name[], bool:dontBroadcast)
{
	//PrintToServer("Player hurt");

	new victimId = GetEventInt(event, "userid");
	new attackerId = GetEventInt(event, "attacker");
	new victim = GetClientOfUserId(victimId);
	new attacker = GetClientOfUserId(attackerId);
	if(g_bFrozen[attacker])
	{		
		if(TF2_GetPlayerClass(victim) == TF_CLASS_SCOUT)
			SetEntProp(victim, Prop_Data, "m_iHealth", 125);
		else
		{
			new victimHp = GetClientHealth(victim);
			SetEntProp(victim, Prop_Data, "m_iHealth", victimHp);
		}
		return Plugin_Continue;
	}
	if(TF2_GetPlayerClass(victim) == TF_CLASS_SCOUT && (TF2_GetPlayerClass(attacker) == TF_CLASS_MEDIC || TF2_GetPlayerClass(attacker) == TF_CLASS_SCOUT))
		FreezePlayer(victim);
	
	return Plugin_Continue;
}

public FreezePlayer(client)
{
	if(g_hUnfreezeTimer[client] == INVALID_HANDLE)
	{
		SetEntProp(client, Prop_Data, "m_iHealth", 65);
		TF2_AddCondition(client, TFCond_Ubercharged, 15.0);
		SetEntityMoveType(client, MOVETYPE_NONE);
	
		g_bFrozen[client] = true;
		g_hUnfreezeTimer[client] = CreateTimer(15.0, AutoUnfreezePlayer, client);
	}
	
	FT_CheckForWinner();
}

public Action:AutoUnfreezePlayer(Handle:timer, any:client)
{	
	if (g_hUnfreezeTimer[client] == timer) //if this timer wasn't killed/updated, let it do it's thing.
	{
		//Small hack to make sure Unfreeze doesn't closehandle this timer while it's active
		
		
		UnfreezePlayer(client);
	}
}

public UnfreezePlayer(client)
{
	g_bFrozen[client] = false;
	
		//If we still have a linked timer, kill it
	if (g_hUnfreezeTimer[client] != INVALID_HANDLE)
	{
			
		KillTimer(g_hUnfreezeTimer[client]);
		g_hUnfreezeTimer[client] = INVALID_HANDLE;
	}
	
	TF2_RemoveCondition(client, TFCond_Ubercharged);
	SetEntityMoveType(client, MOVETYPE_WALK);
		//new Handle:event = CreateEvent("post_inventory_application");
		//SetEventInt(event, "userid", client);
		//FireEvent(event);
}
public Action:Event_BlockWeaponRespawn(Handle:event, const String:name[], bool:dontBroadcast)
{
		//new iClient = GetClientOfUserId(GetEventInt(event, "userid");
		//PrintToServer("Event fired, yo");
	new iClient = GetClientOfUserId(GetEventInt(event, "userid")),
			iClass  = TF2_GetPlayerClass(iClient);

	if(iClass == TF_CLASS_SCOUT)
	{
			//TF2_AddCondition(iClient, 41, 30);	// if scout restrict to melee
			ScoutWeapons(iClient);
	}
	else if(iClass == TF_CLASS_MEDIC)// otherwise they are a medic so we take away their primary gun
	{
		//if(TF2_IsPlayerInCondition(iClient, 41))	// remove condition if player changes to medic from scout
			//TF2_RemoveCondition(iClient, 41);
		
		//TF2_RemoveWeaponSlot(iClient, 0);
		MedicWeapons(iClient);
	}
}

public Event_PlayerClass(Handle:event, const String:name[], bool:dontBroadcast)
{
	new iClient = GetClientOfUserId(GetEventInt(event, "userid")),
			iClass  = GetEventInt(event, "class");

	if(iClass == TF_CLASS_SCOUT)
	{
			//TF2_AddCondition(iClient, 41, 30);	// if scout restrict to melee
			ScoutWeapons(iClient);
	}
	else if(iClass == TF_CLASS_MEDIC)// otherwise they are a medic so we take away their primary gun
	{
		//if(TF2_IsPlayerInCondition(iClient, 41))	// remove condition if player changes to medic from scout
			//TF2_RemoveCondition(iClient, 41);
		
		//TF2_RemoveWeaponSlot(iClient, 0);
		MedicWeapons(iClient);
	}

}


public Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	new iClient = GetClientOfUserId(GetEventInt(event, "userid")),
			iClass  = GetEventInt(event, "class");

	if(iClass == TF_CLASS_SCOUT)
	{
			//TF2_AddCondition(iClient, 41, 30);	// if scout restrict to melee
			ScoutWeapons(iClient);
	}
	else if(iClass == TF_CLASS_MEDIC)// otherwise they are a medic so we take away their primary gun
	{
		//if(TF2_IsPlayerInCondition(iClient, 41))	// remove condition if player changes to medic from scout
			//TF2_RemoveCondition(iClient, 41);
		
		//TF2_RemoveWeaponSlot(iClient, 0);
		MedicWeapons(iClient);
	}
}


/*	Deletes all weapon slots except for melee for the specified client */
stock ScoutWeapons(client)
{
	if (IsClientInGame(client) && IsPlayerAlive(client)) 
	{
		for (new i = 0; i <= 5; i++)
		{
			if (i != 2)
				TF2_RemoveWeaponSlot(client, i);
		}
		
		new weapon = GetPlayerWeaponSlot(client, 2);
		SetEntPropEnt(client, Prop_Send, "m_hActiveWeapon", weapon);
	}
}

/*	Deletes all weapon slots except for melee and healer gun for the specified client */
stock MedicWeapons(client)
{
	if (IsClientInGame(client) && IsPlayerAlive(client)) 
	{
		
				TF2_RemoveWeaponSlot(client, 0);
		
		
		new weapon = GetPlayerWeaponSlot(client, 1);
		SetEntPropEnt(client, Prop_Send, "m_hActiveWeapon", weapon);
	}
}

FT_CheckForWinner() 
{
	if (g_bIsHumiliationRound) //can't win while already in humiliation, silly
		return;

	new bool:redStillActive = false;
	new bool:bluStillActive = false;
	
	for (new i = 1; i <= MaxClients; i++)
	{
		if (IsClientOnValidTeam(i) && !g_bFrozen[i] && TF2_GetPlayerClass(i) != TF_CLASS_MEDIC)
		{

			
			if (GetClientTeam(i) == TF_TEAM_BLU)
			{
					bluStillActive = true;
					PrintToServer("BLUE ACTIVE");
			}
			
			if (GetClientTeam(i) == TF_TEAM_RED)
			{
					redStillActive = true;
					PrintToServer("RED ACTIVE");
			}
			
			//avoid unnecessary tests
			if (redStillActive && bluStillActive)
				break;
		}
	}
	
	if (!redStillActive)
	{
		PrintToServer("blue team won");
		FT_StartHumiliationRound(TF_TEAM_BLU);
	}
	if (!bluStillActive)
	{
		PrintToServer("red team won");
		FT_StartHumiliationRound(TF_TEAM_RED);
	}
}

/*	Timer callback to end the humiliation round */
public Action:FT_TimerEndHumiliation(Handle:timer, any:client)
{
	if (g_bIsHumiliationRound)
	{
		decl String:message[128];
		Format(message, sizeof(message), "%c[FT]%c Mini humiliation round has ended!", cGreen, cDefault);
		PrintToChatAll(message);
		
			
		FT_EndHumiliationRound();
	}
}

/*	Unfreezes all players of the winning team, kills auto unfreeze timers of all the losers (so they can't unfreeze during humiliation)
	and adds a timer to stop the humiliation round 
*/
FT_StartHumiliationRound(winningTeam)
{
	g_bIsHumiliationRound = true;

	
	decl String:message[128];
	Format(message, sizeof(message), "%c[FT]%c %s Team wins this round of freeze tag!", cGreen, cDefault, (winningTeam == TF_TEAM_RED) ? "RED" : "BLU");
	PrintToChatAll(message);

	for (new i = 1; i <= MaxClients; i++)
	{
		//Unfreeze members of the winning team to allow some griefing
		if (g_bFrozen[i] && IsClientOnValidTeam(i))
		{
			if (GetClientTeam(i) == winningTeam)
			{
				PrintToServer("Player %d is unfrozen", i);
				UnfreezePlayer(i);
			}
			else if (g_hUnfreezeTimer[i] != INVALID_HANDLE) 
			{
				//Don't let them auto unfreeze during humiliation round
				CloseHandle(g_hUnfreezeTimer[i]);
				g_hUnfreezeTimer[i] = INVALID_HANDLE;
			}
		}
		else if(!g_bFrozen[i] && IsClientOnValidTeam(i))
		{
			if(GetClientTeam(i) != winningTeam)
			{
				FreezePlayer(i);
				//Don't let them auto unfreeze during humiliation round
				CloseHandle(g_hUnfreezeTimer[i]);
				g_hUnfreezeTimer[i] = INVALID_HANDLE;
			}
		}
	}
	
	//If this round is 0 seconds (disabled), hop right to finishing it. Otherwise, wait.
	new Float:duration = 10.0;

	PrintToChatAll("%c[FT]%c %s Team is stuck for %.1f seconds before being respawned!", 
					cGreen, cDefault, (winningTeam == TF_TEAM_BLU) ? "RED" : "BLU", duration);
					
	CreateTimer(duration, FT_TimerEndHumiliation, winningTeam);
}

/*	Unfreeze and respawn losers. If we are to keep playing freeze tag, start a new round. Otherwise end it */
FT_EndHumiliationRound()
{
	PrintToChatAll("%c[FT]%c Losers have been thawed and respawned!", cGreen, cDefault);
	
	for (new i = 1; i <= MaxClients; i++)
	{
		if (g_bFrozen[i])
		{
			UnfreezePlayer(i);
			TF2_RespawnPlayer(i);
		}
	}
	
	g_bIsHumiliationRound = false;
}

/*	Returns true if the client is actively playing on RED or BLU */
stock bool:IsClientOnValidTeam(client)
{
	//TODO: Might have too many checks here. What is (not) necessary?
	if (!IsClientConnected(client) || !IsClientInGame(client) || !IsPlayerAlive(client))
		return false;

	new team = GetClientTeam(client);
	return (team == TF_TEAM_BLU || team == TF_TEAM_RED);
}

/*	Clear frozen status on a player and checks for a team win in case the  disconnected player was the last one unfrozen. */
public OnClientDisconnect(client)
{		
	UnfreezePlayer(client);
	FT_CheckForWinner();
}

public Event_ClientDisconnect(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	
	databaseClient = client;
	SQL_TConnect(GetDatabase);
	
	//decl String:query[512];
	//Format(query, sizeof(query), "INSERT INTO usersrecord (userID) values ('Bob');");
	//Format(query, sizeof(query),"INSERT INTO usersrecord (userID, userName, gamesPlayed, Freezes, MedicKills, KillsAsJugger, JuggerKills) VALUES ( 'Joe', 'Henry',0,0,0,3,4);"
	//ON DUPLICATE KEY UPDATE gamesPlayed = gamesPlayed + 0, Freezes = Freezes + 0, MedicKills = MedicKills + 0, KillsAsJugger = KillsAsJugger + %d, JuggerKills = JuggerKills + %d;",
								//g_sClientIDS[client],
								//g_sClientName[client],
								//g_iJuggernautKills[client],
								//g_iJuggernautsKilled[client],
								//g_iJuggernautKills[client],
								//g_iJuggernautsKilled[client]
								//);
								
	//PrintToServer(query);
	//SQL_TQuery(db, UpdateDatabase, query, client);
	
}

public GetDatabase(Handle:owner, Handle:hndl, const String:error[], any:data)
{
	if (hndl == INVALID_HANDLE)
	{
		LogError("Database failure: %s", error);
	} 
	else 
	{
		db = hndl;
	
		decl String:query[512];
		//Format(query, sizeof(query), "INSERT INTO usersrecord (userID) values ('Bob');");
		Format(query, sizeof(query),"INSERT INTO usersrecord (userID, userName, Freezes, MedicKills, KillsAsJugger, JuggerKills) VALUES ( '%s','%s',%d,%d,0,0) ON DUPLICATE KEY UPDATE Freezes = Freezes + %d, MedicKills = MedicKills + %d, KillsAsJugger = KillsAsJugger + 0, JuggerKills = JuggerKills + 0;",
								g_sClientIDS[databaseClient],
								g_sClientNames[databaseClient],
								g_iPlayersFrozen[databaseClient],
								g_iMedicKills[databaseClient],
								g_iPlayersFrozen[databaseClient],
								g_iMedicKills[databaseClient]
								);
								
		PrintToServer(query);
		SQL_TQuery(db, UpdateDatabase, query, data);
	}
}

public UpdateDatabase(Handle:owner, Handle:hndl, const String:error[], any:data)
{
	databaseClient = 0;
	if (hndl == INVALID_HANDLE)
	{
		PrintToServer("Query failed! %s", error);
	}

}
